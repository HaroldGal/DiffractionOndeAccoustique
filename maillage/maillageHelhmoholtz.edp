
// Parameters
int nbseg=10;
real R=1, xc=0, yc=0, R2=R/2;
real k=2*pi;
real alpha=0.5;


// border
border circle1(t=0,2*pi){label=1;x=xc+R*cos(t);
y=yc+R2*sin(t);}

border circle2(t=0,2*pi){
				label=2;
				x=xc+R2/4*cos(t);
				y=yc+R2/4*sin(t);}
///plot(circle1(nbseg*2*pi*R)+circle2(nbseg*2*pi*R2)+C1(nbseg),cmm="border");
/// function


func uinc = exp(1i*k*(x*cos(alpha) + y*sin(alpha)));




mesh Th = buildmesh(circle1(nbseg*2*pi*R)+circle2(-nbseg*2*pi*R2));

fespace Vh(Th, P1);
Vh<complex> uh,vh;

solve MonProbleme(uh,vh) = int2d(Th)(dx(uh)*dx(vh)) + int2d(Th)(dy(uh)*dy(vh)) + int2d(Th)(k*uh*vh) - int1d(Th,circle2)(-1i*k*uh*vh)+ on(circle2, uh=uinc);

///plot(Th, cmm="mesh of a circle with subdomain");
Vh<complex> uabs = abs(uh + uinc);
Vh<complex> ure = real(uh);
plot(uabs, wait = true, cmm = "Solution", value = true, fill = true, dim = 2);
include "gmshExport.idp";
gmshExport(Th, uh[], "uh.pos");
gmshExport(Th, ure[], "ure.pos");
gmshExport(Th, uabs[], "uabs.pos");
